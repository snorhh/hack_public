In assembly (and low-level programming in general), when we talk about **"low 32 bits"**, **"low 16 bits"**, **"low 8 bits"**, etc., we’re referring to how many of the **least significant bits** (the rightmost bits) of a register or number we’re working with.

* * *

### 🧠 Background

Computers represent data as binary numbers — a sequence of bits (0s and 1s). The **least significant bits (LSBs)** are on the right side of the number. These bits represent the smaller numeric values.

Example (in 8 bits):

```
Binary:  1011 0110
Bits:    [7][6][5][4][3][2][1][0]
Value:   MSB             LSB
```

- **MSB** = most significant bit (leftmost)
    
- **LSB** = least significant bit (rightmost)
    

* * *

### 💾 Registers and Bit Ranges

On x86 CPUs, registers have names depending on how many of their bits you’re accessing:

| Bits | Register Example | Description |
| --- | --- | --- |
| 64  | `rax` | Full 64-bit register |
| 32  | `eax` | Low 32 bits of `rax` |
| 16  | `ax` | Low 16 bits of `rax` |
| 8   | `al` | Low 8 bits of `ax` |
| 8   | `ah` | High 8 bits of `ax` |

So if you write to `eax`, you’re only changing the **lower 32 bits** of `rax`. The higher 32 bits are automatically cleared to zero on x86-64.

* * *

### 🧩 Example

Let’s say:

```
rax = 0x1234567890ABCDEF
```

Then:

```
eax (low 32 bits) = 0x90ABCDEF
ax  (low 16 bits) = 0xCDEF
al  (low 8 bits)  = 0xEF
ah  (next 8 bits) = 0xCD
```

The **"low X bits"** just means you’re taking the rightmost part of the binary number, ignoring the rest.

* * *

### ⚙️ Why It Matters

- Different instructions operate on different bit sizes.
    
- Accessing the low part of a register is common for smaller data types (like bytes or words).
    
- Understanding this helps avoid overwriting or accidentally zeroing parts of registers.
    

In short: **"low 32 bits" means the rightmost 32 bits — the smaller end of the value.**

&nbsp;

The **stack pointer (SP)** is a special register in a CPU that keeps track of where the **top of the stack** is in memory.

* * *

### 🧱 What’s the Stack?

The **stack** is a region of memory used to store temporary data — like:

- Function call return addresses
    
- Local variables
    
- Saved register values
    

You can think of it like a real stack of plates:

- When you **push**, you put a new plate (value) on top.
    
- When you **pop**, you remove the top plate (value).
    

* * *

### 📍 The Stack Pointer’s Job

The **stack pointer (SP)** always points to the **current top of the stack** in memory.

- When you **push** something, SP moves to a *lower* address (the stack grows downward in most systems).
    
- When you **pop**, SP moves *upward* (back toward higher addresses).
    

Example (in 64-bit mode):

- The stack pointer register is called **RSP** (register stack pointer).
    
- In 32-bit mode, it’s **ESP**.
    

* * *

### 🧩 Example

Suppose RSP = 0x7FFFFFFFE000

```
push rax   → RSP = 0x7FFFFFFFDF F8   (decreases)
             [value of RAX stored at new top]

pop rbx    → RBX = [value from stack]
             RSP = 0x7FFFFFFFE000     (increases)
```

The CPU automatically adjusts RSP when `push` or `pop` instructions are used.

* * *

### 🧠 Why It’s Important

- Every function call uses the stack pointer to keep track of its own data.
    
- If the stack pointer is corrupted (e.g. overwritten accidentally), your program can crash.
    
- Understanding SP helps you debug segmentation faults and understand call stacks.
    

* * *

In short: the **stack pointer** is like a bookmark telling the CPU, “here’s where the top of the stack currently is.”

&nbsp;

### 🧠 Registers vs Memory Locations

In assembly and computer architecture, both **registers** and **memory locations** are places where data is stored — but they’re very different in speed, size, and purpose.

* * *

### ⚡ Registers

- Registers are **tiny, ultra-fast storage areas inside the CPU** itself.
    
- They hold the data the processor is currently working on — like numbers for arithmetic, addresses, or flags.
    
- Each register has a specific name and size (for example, `rax`, `rbx`, `rcx`, etc. on x86-64).
    
- Registers are directly accessible by most instructions.
    

Example:

```assembly
mov rax, 5      ; store 5 in register rax
add rax, 3      ; add 3 to the value in rax
```

The operation happens entirely inside the CPU — no need to access main memory.

**Key traits:**

- Located **inside** the CPU.
    
- Extremely fast (nanoseconds or less).
    
- Very limited in number (a few dozen at most).
    
- Used for temporary data and computation.
    

* * *

### 💾 Memory Locations

- Memory (RAM) is **external to the CPU**, a much larger but slower storage area.
    
- It holds programs, variables, and data for long-term use during execution.
    
- You access memory by **address** (like 0x7FFE1234).
    

Example:

```assembly
mov rax, [0x7FFE1234]   ; load the value from memory into rax
mov [0x7FFE1234], rbx   ; store the value of rbx into memory
```

**Key traits:**

- Located **outside** the CPU.
    
- Slower (hundreds of CPU cycles).
    
- Vast in size (gigabytes).
    
- Used for all program data and instructions.
    

* * *

### ⚙️ The Difference in Practice

| Feature | Register | Memory Location |
| --- | --- | --- |
| Location | Inside CPU | In RAM |
| Speed | Very fast | Slower |
| Size | Tiny (bytes per register) | Huge (gigabytes) |
| Access | By name (e.g. RAX) | By address (e.g. \[0x7FFF...\]) |
| Use | Temporary computation | General data storage |

* * *

### 🧩 Summary

- **Registers** = CPU’s short-term workspace.
    
- **Memory** = The computer’s long-term workspace during execution.
    

You can think of it like this:

> Registers are your hands — fast, small, and for immediate tasks.  
> Memory is your desk — slower to reach, but can hold a lot more stuff.

## 🐍 Python Introduction — Beginner’s Guide with Examples

This guide covers the key concepts from the Python Tutorial’s *Introduction* section, explained clearly with **examples** and **step-by-step explanations**.

* * *

### 🧮 1. Python as a Calculator

Python can be used like a calculator. You can perform arithmetic directly in the interpreter.

```python
>>> 2 + 3
5

>>> 10 - 4
6

>>> 5 * 6
30

>>> 8 / 2  # Division always gives a float
4.0

>>> 8 // 3  # Floor division (drops decimals)
2

>>> 8 % 3   # Modulus (remainder)
2

>>> 2 ** 5  # Exponentiation (2 to the power of 5)
32
```

#### Variables

You can store values in variables using `=`.

```python
>>> x = 10
>>> y = 3
>>> result = x * y
>>> print(result)
30
```

Variables can hold different types:

```python
name = "Alice"
age = 25
pi = 3.14159
```

If you try to use a variable before assigning it, you’ll get an error:

```python
>>> print(z)
NameError: name 'z' is not defined
```

* * *

### 🧵 2. Strings (Text)

Strings hold text. You can use single or double quotes.

```python
>>> 'hello'
'hello'

>>> "world"
'world'
```

You can include quotes inside strings by using the opposite type or escaping:

```python
>>> "I'm learning Python"
"I'm learning Python"

>>> 'He said, "Hello!"'
'He said, "Hello!"'

>>> 'It\'s easy to escape quotes'
"It's easy to escape quotes"
```

#### String Operations

```python
>>> greeting = "Hello"
>>> name = "Bob"
>>> message = greeting + ", " + name  # Concatenation
>>> print(message)
Hello, Bob

>>> laugh = "ha" * 3  # Repetition
>>> print(laugh)
hahaha
```

#### Indexing and Slicing

Strings are sequences, so you can access parts of them using indices.

```python
>>> word = "Python"
>>> word[0]  # First character
'P'

>>> word[5]  # Last character (index 5)
'n'

>>> word[-1]  # Negative index counts from the end
'n'

>>> word[0:2]  # Slice from index 0 up to (not including) 2
'Py'

>>> word[2:]
'thon'

>>> word[:3]
'Pyt'
```

Strings are **immutable**:

```python
>>> word[0] = 'J'
TypeError: 'str' object does not support item assignment
```

To modify text, create a new string:

```python
>>> new_word = 'J' + word[1:]
>>> print(new_word)
Jython
```

* * *

### 📦 3. Lists

Lists can hold multiple items — numbers, strings, or even other lists.

```python
>>> numbers = [1, 2, 3, 4]
>>> words = ["apple", "banana", "cherry"]
>>> mixed = [1, "two", 3.0, [4, 5]]
```

Access items by index:

```python
>>> numbers[0]
1
>>> words[-1]
'cherry'
```

#### Modifying Lists (Lists are mutable)

```python
>>> numbers[1] = 20
>>> print(numbers)
[1, 20, 3, 4]

>>> numbers.append(5)  # Add to the end
>>> print(numbers)
[1, 20, 3, 4, 5]

>>> numbers[:3] = [10, 11, 12]  # Replace a slice
>>> print(numbers)
[10, 11, 12, 4, 5]
```

#### Nesting Lists

```python
>>> nested = [numbers, ["x", "y", "z"]]
>>> nested[0][1]
11
>>> nested[1][2]
'z'
```

#### List References

Assigning one list to another does **not** copy it — both variables refer to the same list.

```python
>>> a = [1, 2, 3]
>>> b = a
>>> b[0] = 99
>>> print(a)
[99, 2, 3]  # a changed too!
```

To copy a list, use slicing:

```python
>>> c = a[:]
>>> c[0] = 0
>>> print(a)
[99, 2, 3]
>>> print(c)
[0, 2, 3]
```

* * *

### 🔁 4. First Steps Toward Programming

Let’s build a simple program: generating Fibonacci numbers less than 100.

```python
a, b = 0, 1
while a < 100:
    print(a)
    a, b = b, a + b
```

Output:

```
0
1
1
2
3
5
8
13
21
34
55
89
```

#### Explanation

- `a, b = 0, 1` assigns both at once.
    
- `while a < 100:` repeats as long as `a` is less than 100.
    
- Inside the loop, we print `a` and update both `a` and `b`.
    
- **Indentation** (the spaces before `print` and `a, b = ...`) defines the code inside the loop.
    

#### Conditional Example

```python
x = 10
if x > 0:
    print("Positive")
elif x == 0:
    print("Zero")
else:
    print("Negative")
```

* * *

### ✅ Summary of Key Points

- `+`, `-`, `*`, `/`, `//`, `%`, and `**` are arithmetic operators.
    
- Variables are created with `=`.
    
- Strings (`str`) are **immutable** sequences of characters.
    
- Lists (`list`) are **mutable** and can hold mixed types.
    
- Indentation defines structure in Python.
    
- Loops (`while`) and conditions (`if`) control flow.
    

* * *

## 🧭 Python Control Flow Tools — Beginner’s Guide with Examples

This chapter expands your understanding of how Python makes decisions and repeats actions. You’ll learn about **if statements, loops, range(), break/continue, functions**, and more — with clear examples.

* * *

### ⚖️ 1. The `if` Statement

Python uses `if`, `elif`, and `else` for conditional logic.

```python
x = 15

if x < 0:
    print("Negative")
elif x == 0:
    print("Zero")
elif x < 10:
    print("Small number")
else:
    print("Large number")
```

Explanation:

- `if` checks the first condition.
    
- `elif` means “else if,” checking the next condition only if the previous ones were false.
    
- `else` runs when nothing else matches.
    

Python relies on **indentation** (spacing) to know what belongs inside the condition.

* * *

### 🔁 2. `for` Loops

`for` loops let you repeat actions for each item in a sequence (like a list, tuple, or string).

```python
words = ["cat", "window", "defenestrate"]
for w in words:
    print(w, len(w))
```

Output:

```
cat 3
window 6
defenestrate 12
```

You can loop over **any iterable** (list, string, range, etc.).

```python
for letter in "Python":
    print(letter)
```

Output:

```
P
y
t
h
o
n
```

* * *

### 📏 3. The `range()` Function

`range()` generates a sequence of numbers.

```python
for i in range(5):  # 0, 1, 2, 3, 4
    print(i)
```

`range(start, stop, step)` allows more control:

```python
for i in range(2, 10, 2):  # start=2, stop=10, step=2
    print(i)
```

Output:

```
2
4
6
8
```

You can combine `range()` with `len()` to loop through indexes:

```python
words = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(words)):
    print(i, words[i])
```

* * *

### 🚫 4. `break` and `continue` Statements

#### `break`

Stops the loop completely.

```python
for n in range(10):
    if n == 5:
        break
    print(n)
```

Output:

```
0
1
2
3
4
```

#### `continue`

Skips the rest of the loop for this iteration.

```python
for n in range(6):
    if n % 2 == 0:
        continue
    print(n)
```

Output:

```
1
3
5
```

* * *

### ⚙️ 5. The `else` Clause on Loops

An optional `else` block can run when the loop finishes normally (not interrupted by `break`).

```python
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        print(n, 'is a prime number')
```

Output:

```
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
```

* * *

### 🔄 6. `pass` Statement

`pass` is a placeholder that does nothing. It’s useful when you need a statement syntactically but don’t want any action yet.

```python
for letter in 'Python':
    if letter == 'h':
        pass  # to be implemented later
    print(letter)
```

* * *

### 🧩 7. Defining Functions with `def`

Functions let you group code into reusable blocks.

```python
def greet(name):
    print("Hello,", name)

# Call the function
greet("Alice")
greet("Bob")
```

You can have multiple parameters and even return values.

```python
def add(a, b):
    return a + b

result = add(3, 4)
print(result)  # 7
```

* * *

### 🎯 8. Default Argument Values

You can define default values for parameters.

```python
def power(base, exponent=2):
    return base ** exponent

print(power(3))     # 9 (uses default exponent=2)
print(power(3, 3))  # 27
```

* * *

### 🧱 9. Keyword Arguments

You can call functions using parameter names.

```python
def describe_pet(animal, name):
    print(f"I have a {animal} named {name}.")

describe_pet(animal="dog", name="Buddy")
describe_pet(name="Mittens", animal="cat")
```

* * *

### 🌟 10. `return` Statement and None

If a function doesn’t explicitly return a value, it returns `None`.

```python
def say_hello():
    print("Hello!")

result = say_hello()
print(result)  # None
```

* * *

### 🧮 11. Nested Functions and Scope (Brief Intro)

Variables inside a function are **local** — they don’t affect variables outside.

```python
x = 10

def show():
    x = 5  # local variable
    print("Inside function:", x)

show()
print("Outside function:", x)
```

Output:

```
Inside function: 5
Outside function: 10
```

* * *

### ✅ Summary of Key Concepts

| Concept | Description | Example |
| --- | --- | --- |
| `if / elif / else` | Conditional branching | Decide what to do based on a value |
| `for` | Loop over items | `for i in range(5)` |
| `range()` | Sequence generator | `range(2, 10, 2)` |
| `break` / `continue` | Control loop behavior | Stop early / skip current iteration |
| `else` with loops | Run code if no `break` occurred | Checking for primes |
| `pass` | Placeholder statement | Used in empty blocks |
| `def` | Define a function | `def greet(name): ...` |
| Default & keyword args | Flexible function calling | `power(3)` or `power(3, 3)` |

* * *

## 🧩 Python Classes — Concise Beginner’s Guide

This chapter introduces **object-oriented programming (OOP)** in Python. You’ll learn how to group data and behavior together using **classes**.

* * *

### 🧱 1. What Is a Class?

A **class** defines a *blueprint* for objects — combining **data (attributes)** and **functions (methods)**.

```python
class Dog:
    def __init__(self, name, age):  # Constructor
        self.name = name
        self.age = age

    def bark(self):
        print(f"{self.name} says woof!")
```

`self` refers to the current object. Every method must include it as the first parameter.

Create an object (an *instance*) from the class:

```python
my_dog = Dog("Buddy", 4)
my_dog.bark()  # Buddy says woof!
```

* * *

### ⚙️ 2. Instance Attributes vs. Class Attributes

- **Instance attributes** belong to one object.
    
- **Class attributes** are shared by all objects.
    

```python
class Cat:
    species = "mammal"  # class attribute

    def __init__(self, name):
        self.name = name  # instance attribute

cat1 = Cat("Misty")
cat2 = Cat("Luna")

print(cat1.species)  # mammal
print(cat1.name)     # Misty
```

* * *

### 🔁 3. Methods

Methods are just functions inside a class.

```python
class Counter:
    def __init__(self):
        self.count = 0

    def increment(self):
        self.count += 1

c = Counter()
c.increment()
print(c.count)  # 1
```

* * *

### 🧬 4. Inheritance

A class can inherit from another class to reuse code.

```python
class Animal:
    def speak(self):
        print("Some sound")

class Dog(Animal):
    def speak(self):  # Override
        print("Woof!")

d = Dog()
d.speak()  # Woof!
```

Use `super()` to call the parent’s version:

```python
class Bird(Animal):
    def speak(self):
        super().speak()
        print("Chirp!")
```

* * *

### 🧠 5. Special (Magic) Methods

These methods start and end with double underscores — used to customize class behavior.

```python
class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y

    def __str__(self):
        return f"({self.x}, {self.y})"

p = Point(2, 3)
print(p)  # (2, 3)
```

Common magic methods:

| Method | Used For |
| --- | --- |
| `__init__` | Object creation |
| `__str__` | String representation |
| `__len__` | Length (`len(obj)`) |
| `__add__` | Addition (`obj1 + obj2`) |

* * *

### 🪄 6. Encapsulation and Privacy

Use `_` or `__` to indicate private attributes (convention only).

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # private

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance
```

* * *

### ✅ Summary

| Concept | Example |
| --- | --- |
| Define class | `class Dog:` |
| Create object | `d = Dog()` |
| Constructor | `def __init__(self):` |
| Method | `def bark(self):` |
| Inheritance | `class Dog(Animal):` |
| Magic methods | `__init__`, `__str__` |
| Private vars | `_hidden`, `__very_hidden` |

* * *

**Tip:** Classes let you build your own data types — organizing logic and data together, just like how `list` or `str` work internally.

&nbsp;

&nbsp;
