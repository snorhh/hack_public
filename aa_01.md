### Ffuf
https://terokarvinen.com/2023/fuzz-urls-find-hidden-directories/
#### Vaiheet
MUISTA, kaksi Ã¤ffÃ¤Ã¤ alussa!

- tarvitaan sanakirja
- katso parametrit ./ffuf -> KUN OLET BIN-kansiossa (kokeile | less tai & less)
- __./ffuf -w common.txt -u http://1270.0.0.2:800/FUZZ__
- eli -w worldist ja -u target url
- nyt siis fuzzataan wordlista sinne urlinperÃ¤Ã¤n
- jos nÃ¤kyy pelkkiÃ¤ status-Ok niin filterÃ¶idÃ¤Ã¤n

FILTER OPTIONS:
 -fc Filter HTTP __status codes__ from response. Comma separated list of codes and ranges
 -fl Filter by __amount of lines__ in response. Comma separated list of line counts and ranges
 -fmode Filter set operator. Either of: and, or (default: or)
 -fr Filter regexp
 -fs Filter __HTTP response size__. Comma separated list of sizes and ranges
 -ft Filter by __number of milliseconds__ to the first response byte, either greater or less than. EG: >100 or <10
 -fw Filter by __amount of words__ in response. Comma separated list of word counts and ranges

esim. `./ffuf -w common.txt -u http://127.0.0.2:8000/FUZZ -fs 132`  
eli ottaa pois ne, jotka ovat 132 tavua


## Quick flags reminder

* `-u` URL (use `FUZZ` in path or in headers/body)
* `-w` wordlist (`wordlist[:placeholder]` for multiple `-w`)
* `-H` add header (can include `FUZZ`)
* `-d` request body (for POST; include `FUZZ` where needed)
* `-X` HTTP method (e.g. `POST`)
* `-mode` `clusterbomb` / `pitchfork` / `sniper`
* `-mc` match status codes (e.g. `-mc 200,301`)
* `-fc` filter status codes (e.g. `-fc 404`)
* `-fs` filter by response size
* `-fw` filter by word count
* `-fl` filter by line count
* `-o` output file, `-of` output format (`json`, `html`, `e` etc.)

* Show only 200s: `-mc 200`
* Exclude 404s: `-fc 404`
* Exclude responses of size 0 or specific sizes: `-fs 0` / `-fs 1234`
* Filter by number of words: `-fw 0`

Suoritin ffufin komennolla `ffuf -w common.txt -u http://127.0.0.2:8000/FUZZ`. Yritin ensin ajaa sitÃ¤ samassa komentokehoteikkunassa, kunnes muistin, ettÃ¤ __piti avata toinen ikkuna__.

FiltterÃ¶in tuloksia pituuden mukaan, ja koska 154 oli yleinen pituus, niin kÃ¤ytin sitÃ¤ filtteriehtona. `ffuf -w common.txt -u http://127.0.0.2:8000/FUZZ -fs 154`

Vinkki: kokeile `curl -i http.....git/HEAD`, joka lÃ¶ytyy kaikista gittirepoista

__Tsekkaa aina /robots.txt__

__Tsekkaa nÃ¤kyy javascriptissÃ¤ jotain (esim. url)__

__Tsekkaa toimiiko /ADMIN/DELETEUSER vaikka /admin/deleteuser ei toimi__

/admin/deleteUser.anything saattaa mÃ¤tsÃ¤tÃ¤ /admin/deleteUser

tai jopa viimeinen / tai ilman


Sivulla piti laittaa salasana ja "reveal my password" nÃ¤ytti oliko se oikein. SyÃ¶ttÃ¶kenttÃ¤ hyvÃ¤ksyi vain numeroita, mutta se oli selaimen tekemÃ¤ rajoitus. Inspectorilla nÃ¤kyi <input type="number" name="pin" value="0">. Siihen pystyy esim. laittamaan type="string" tai "text"


```sql
SELECT password FROM pins WHERE pin = '0' OR 1=1 -- ';
```
* Many DBs require a space after `--` (use `-- `). MySQL accepts `#` as a line comment. Block comments `/* ... */` work across many DBs.

If the application constructs the query without quotes (e.g., `WHERE pin = 0`), you **must not** start with a quote. Instead use unquoted logic:

```
0 OR 1=1 --
```



* Inspect whether the application uses quotes around the parameter. If yes, start with `'` to close the string; if no, do not use the initial quote.
* Add injected logic (e.g., `OR 1=1` or a boolean condition targeting a field).
* Add a comment token (`-- `, `#`, or `/*`) to swallow the trailing characters.
* To extract specific rows, use `LIMIT offset,count` or `LIMIT count OFFSET offset`.
* URL-encode spaces and punctuation when sending via HTTP (`%20` for space, etc.).

* `ORDER BY id ASC` â†’ sorts rows by the `id` column in ascending order.
* `LIMIT 1 OFFSET 2` â†’ skip the first 2 rows, return 1.
This guarantees you get the *third* row by id.

| Goal                               | Recommended syntax                        |
| ---------------------------------- | ----------------------------------------- |
| Deterministic single-row selection | `ORDER BY id ASC LIMIT 1 OFFSET n`        |
| MySQL shorthand                    | `ORDER BY id ASC LIMIT n,1`               |
| Paginate efficiently               | Keyset pattern using `WHERE id > last_id` |

### Strings

strings a.out

strings secret.bin | grep password

strings -n 6 malware.bin


```
strings -t x binaryfile
```

â†’ Prints each string with its offset in hexadecimal.

Useful for knowing where in memory or the file a string appears.

Example output:

```
  12ab Hello world
  13f2 /etc/passwd
```

`xxd` is a command-line tool that creates a **hex dump** of a file or standard input. It can also do the reverse â€” **convert a hex dump back to binary**.

### **Example Output**

```
00000000: 4865 6c6c 6f20 576f 726c 6421       Hello World!
```

* `00000000`: Offset (hex position in file)
* `4865 6c6c 6f20 576f 726c 6421`: Bytes in hex
* `Hello World!`: ASCII interpretation of those bytes

# C â€” Basics for Beginners


```bash
# compile
gcc -std=c17 -O2 -Wall hello.c -o hello
# debug
gcc -g -O0 -Wall hello.c -o hello_debug
# run
./hello
```

## Hello world (example)

```c
#include <stdio.h>
int main(void) {
    printf("Hello, world
");
    return 0;
}


## Core primitives (one-liners)

```c
int i = 42;            // integer
char c = 'A';          // char
float f = 3.14f;       // float
char s[] = "hi";     // string (NUL-terminated array)
int *p = &i;           // pointer
int a[3] = {1,2,3};    // array
```

`sizeof(type)` -> bytes. `NULL` is null pointer.



Vinkki: sen sijaan ettÃ¤ laittaa \merkki niin voi laittaa koko stringin 'sisÃ¤Ã¤n'.

__HUOM__ ascii lista
https://www.eso.org/~ndelmott/ascii.html

https://www.geeksforgeeks.org/dsa/ascii-table/


### ðŸ§  GDB and Conversion Reference Guide

* * *

## ðŸ§© GDB Basics

### `x/s $rdi`

Examine memory as a string at the address stored in the **RDI register**.

```bash
(gdb) x/s $rdi
```

â†’ Displays the string pointed to by RDI.

### `set $buf = $rsi`

Creates a custom GDB variable `$buf` with the same value as `$rsi`.

```bash
(gdb) set $buf = $rsi
(gdb) x/s $buf
```

â†’ Handy for tracking pointers while stepping.

### Stepping Commands

| Command | Level | Steps Into Functions? | Description |
| --- | --- | --- | --- |
| `n` | Source | âŒ No | Run next C line, skip calls |
| `s` | Source | âœ… Yes | Run next C line, step into calls |
| `ni` | Instruction | âŒ No | Run next assembly instruction, skip calls |
| `si` | Instruction | âœ… Yes | Run next assembly instruction, step into calls |

**In short:** `n/s` for source, `ni/si` for assembly. `next` skips, `step` enters.


### Opening `.docx` Files in Linux

| Purpose | Command |
| --- | --- |
| View/Edit | `libreoffice document.docx` |
| Default App | `xdg-open document.docx` |
| View Text | `catdoc document.docx` or `docx2txt document.docx` |
| Inspect Internals | `7z x document.docx -odocx_contents` |

> `.docx` = ZIP archive. Main content: `word/document.xml`.

### 7-Zip `-o` Option

No space between `-o` and folder name.

7z x file.zip -ooutput_folder


```bash
binwalk -eM firmware.bin
```

â†’ Extracts and scans nested files inside firmware.


## ðŸ§© Ultimate Encoding & Conversion Guide

### 1\. Hex â†” Bytes

```python
b = bytes.fromhex("48656c6c6f")  # hex â†’ bytes
h = b.hex()                      # bytes â†’ hex
```

### 2\. Base64 â†” Bytes

```python
import base64
b64 = base64.b64encode(b"Hello")
raw = base64.b64decode(b64)
```

### 3\. Strings â†” Bytes

```python
b = "Hello".encode()
t = b.decode()
```

### 4\. Mixing Conversions

```python
data = base64.b64encode("Hello".encode())
text = base64.b64decode(data).decode()
```

### 5\. Int â†” Bytes

```python
n = 1024
b = n.to_bytes(2, 'big')
i = int.from_bytes(b, 'big')
```

### 6\. CLI Tools

| Conversion | Linux Command |
| --- | --- |
| Hex dump | `xxd file` |
| Base64 encode | `base64 file` |
| Base64 decode | `base64 -d file` |

### Quick Summary

| Type | To Bytes | From Bytes |
| --- | --- | --- |
| **Hex** | `bytes.fromhex()` | `.hex()` |
| **Base64** | `b64decode()` | `b64encode()` |
| **String** | `.encode()` | `.decode()` |
| **Int** | `.to_bytes()` | `int.from_bytes()` |

> Always convert to **bytes** first â€” most encodings work from there.























